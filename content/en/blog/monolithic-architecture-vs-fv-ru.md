# Молоток в поисках гвоздей

В процессе разработки нового инструмента в какой-то момент неизбежно возникает
вполне резонная потребность испытать его за пределами собственной мастерской, в
неконтролируемой среде реальных задач. Наш инновационный фреймворк для
специфицирования и верификации программ **Inference** как раз подходит к этой
стадии, побуждая своих создателей примерять сей футуристичный молоток к каждому
встречному гвоздю. Однако, поскольку часов в сутках только 24, а проектов на
гитхабе, к которым, в теории, можно было бы приложить формальные методы,
существенно больше, чем имеет смысл считать, приходится каким-то образом
фильтровать потенциальный фронт работ.

По очевидным причинам, когда речь идёт о способах повышения надёжности программ,
фокусировать внимание разумно на проектах с более высокой ценой ошибки, так что
блокчейн-платформы неизбежно оказываются в начале списка - ущерб от нештатныч
ситуаций в крипто-финансовой индустрии почти всегда имеет прямую монетарную
оценку, среднее значение которой из года в год только растёт. В качестве второго
естественного критерия отсева выступает технологический стек - опытным полигоном
для нашей технологии стала механизация стандарта WebAssembly. Таким образом,
шорт-лист "гвоздей", подходящих нашему "молотку" на текущем этапе, можно
составить из блокчейн-платформ, использующих WebAssembly в качестве основного
таргета компиляции. В рамках этого разговора мы затронем три таких проекта:
Polkadot Substrate, Stellar Soroban и Arbitrum Stylus.

При взгляде на эту троицу издали в глаза бросается некоторое поверхностное
родство - все они используют Rust в качестве одного из основных языков
разработки контрактов, а платформа WebAssembly является фундаментом их рантайма.
Однако, при более пристальном рассмотрении через оптику формальной
верифицируемости начинают проявляться фундаментальные архитектурные отличия, о
которых мне и хотелось бы здесь поговорить.

# Polkadot Substrate

Фреймворк за авторством Web3 Foundation представляет собой непрерывно
пополняющуюся коллекцию готовых решений для основных паттернов криптофинансового
учёта, организованную в виде собрания модулей специальной структуры
(`pallet`-ов) на языке Rust. Высокотехнологичная система сборки позволяет
комбинировать эти модули произвольным образом, производя тем самым на свет новые
версии рантайма, содержащие только необходимую для каждого отдельного случая
функциональность. Основные архитектурные принципы коллекции можно попытаться
сформулировать следующим образом:

1. `pallet` как универсальная единица интеграции. Любая функциональность,
которая может понадобиться блокчейн-разработчику, от отдельных аспектов
инфраструктуры до популярных паттернов бизнес-логики, предоставляется в виде
единообразно подключаемых модулей.

2. Активное использование Rust-овской системы типов и продвинутых средств
метапрограммирования в горизонтальном взаимодействии модулей для максимально
комфортного и безопасного переиспользования кода.

3. Большое внимание к оптимизации производительности рантайма с применением
наиболее мощных методик. Агрессивный инлайнинг на этапе LTO - настройка "по
умолчанию" при сборке конечного бинарника.

Сперва может показаться, что перечисленные выше качества - хвалебная ода, но, к
сожалению, у подобной архитектуры есть тёмная сторона, неизбежно вытекающая из
той же комбинации факторов, что создают её достоинства. И в тени этой, увы,
скрываются проблемы, способные, фактически, поставить крест на применимости
целого класса методов формально удостовериться в надёжности системы как в целом,
так и по частям.

Когда речь идёт о методологическом эталоне формальных методов - верификации
исполняемых бинарных модулей на уровне семантики платформы - от любой достаточно
крупной кодовой базы, подлежащей верификации, требуется ряд свойств, о которых
обычно программисты беспокоятся редко. Возникают эти требования в связи с
фундаментальными принципами рассуждений об алгоритмах и являются, по факту,
обязательными:

1. Сложные системы не верифицируемы целиком. Единственный практический способ
верификации сложных систем состоит в их разбиении и специфицировании максимально
изолированных друг от друга подсистем, верифицируемых после этого независимо
друг от друга.

2. Суммарные затраты на верификацию растут пропорционально квадрату количества
подсистем, делящих общее пространство состояний. Без чётко очерченных границ
"владений", нерушимость которых обеспечивается на уровне платформы, при
верификации приходится исходить из презумпции взаимного влияния всех на всех.

3. Переиспользование суждений о свойствах алгоритмов гораздо сложнее
переиспользования самих алгоритмов. Мономорфизация и инлайнинг, фактически,
бесплатны для разработчика и конечного пользователя, но весьма дорогостоящи в
контексте формальной верификации - каждая копия кода, произведённая этими
процедурами, становится отдельной целью, требующей самостоятельного покрытия.

В таком свете внезапно оказывается, что архитектура FRAME, к сожалению, делает
выбор в пользу усложнения задачи формальной верификации практически на каждом
повороте. Да, на уровне исходного кода система паллетов прямо-таки излучает
гибкость, модульность и удобство использования. Однако, полноценная формальная
верификация исходных кодов на языке Rust ещё долго будет оставаться утопической
мечтой (просто за отсутствием официальной спецификации его семантики), тогда как
на уровне исполняемых бинарников картина становится намного печальней.

Центральная проблема состоит в том, что все структурные границы между модулями
исходного кода полностью стираются сборочным процессом на достаточно раннем
этапе. Фактически, возможность использовать в одном паллете макроопределения из
другого эродирует их ещё на стадии препроцессинга. Если же дизассемблировать
конечный результат - официальный рантайм Polkadot-а, скажем - результат вообще
будет представлять собой один монолитный модуль на два с лишним миллиона
инструкций, где для очень редкой функции можно однозначно установить её
принадлежность к какому-либо паллету. Хуже того, в центре этого артефакта будет
лежать одна функция на несколько сотен тысяч строк, порождённая автоматическим
инлайнингом мириады совершенно разнородных по функциональности кусков кода из
всех уголков проекта непосредственно в тело центрального диспетчера событий.

Увы, но единственное, что может сделать любой инженер по формальной верификации,
столкнувшись с таким фронтом работ - это развести руками и сдаться, поскольку
на данный момент специфицирование и доказательство корректности в подобных
условиях технологически почти невозможно, а экономически просто абсурдно. Даже
если каким-то чудом можно было бы создать всеобъемлещую и строго доказанную
спецификацию конкретной версии рантайма Polkadot, это достижение оказалось бы
совершенно непереносимо не только на его производные форки с другим составом
включённых паллетов, но даже на следующие версии самого Polkadot-а. Да что там,
учитывая отсутствие надёжного детерминизма в сборочном процессе Rust даже при
сэндбоксинге `docker`-ом, для инвалидации иногда достаточно будет просто
пересобрать бинарник на другой машине - из-за гонки потоков (по-видимому) при
распараллеливании компиляции, адресное пространство общей памяти и порядковая
индексация функций перемешиваются совершенно свободно.

Возможно ли малой кровью компенсировать как-то вышеперечисленные проблемы, не
производя радикального пересмотра архитектуры? Вопрос непростой, учитывая то,
сколь семимильными шагами движется прогресс в этой области. Не исключено, что
уже через считанные годы автоматизация верификации при помощи LLM позволит
просто закидать все пробемы масштаба стойкой с видеокартами. Но до той поры,
боюсь, прогноз неутешительный - попытки получить формальное подтверждение
корректности любого рантайма, наследующего кодовую базу Polkadot, в том виде, в
котором он развёртывается и исполняется, представляются нецелесообразными. Это
не должно, однако, отвращать его пользователей и разработчиков от применения
формальных методов для повышения надёжности в меньшем масштабе - нетривиальную
арифметику в важных функциях, например, можно верифицировать на уровне
псевдокода, а изоляция контрактов в отедльных wasm-модулях позволяет
задумываться о верификации на уровне ассемблера хотя бы их.

# Stellar Soroban

При столкновении с этой платформой после Substrate первое, что бросается в
глаза - радикальный минимализм. Выделенное ядро криптографического леджера
содержит всего 500 тысяч строк весьма ортодоксального подмножества C/C++.
Никаких излишеств, только базовая функциональность сетевого протокола и
алгоритм, реализующий распределённый консенсус. Опциональных компонентов просто
нет - каждая функция необходима для работоспособности системы.
Метапрограммирование и полиморфизм почти не используются - классический
процедурный код прямолинейно оперирует явно определёнными структурами данных.
Так писали код наши деды и прадеды, пошутите, вероятно, вы, и будете недалеки от
истины - действительно, с поправкой на прогресс стека TCP/IP и небольшое
художественное преувеличение, ядро Stellar можно было бы собрать для мэйнфрейма
прошлого тысячелетия компилятором из середины 90-х.

Однако, было бы большой ошибкой принимать этот минимализм за архаичность.
Некоторые методологии разработки мало меняются с годами по той же причине, по
которой не эволюционируют крокодилы - из-за идеальной приспособленности к своей
экологической нише. Как бы парадоксально это ни звучало, но если вы планируете
систему, подлежащую формальной верификации на уровне исполняемого бинарника,
классический процедурный стиль прямолинейного оперирования явно определёнными
структурами данных - ваш лучший (а с ростом размеров системы единственный) шанс.

Дело в том, что этот, казалось бы, архаичный метод разработки оптимизирован с
точки зрения главного параметра, влияющего на верифицируемость системы в целом -
структурной дистанции между исходным кодом и ассемблерным листингом. Сознательно
отказываясь от привычных современному программисту комфорта и гибкости, мы в
обмен получаем неоценимое для рассуждений об алгоритмах преимущество -
возможность, фактически, построчного сопоставления операторов и выражений языка,
используемого программистом, с компактными группами ассемблерных инструкций,
получаемых на выходе сборочного процесса. Та ясность мысли разработчика, которая
полностью теряется при перемалывании мясорубкой дополнительных слоёв абстракции,
трансформирующих код в сложных пайплайнах более современных языков, при
прохождении через тривиальный до прозрачности процесс компиляции ортодоксального
C/C++, сохраняется в относительной целости и может быть прочитана
натренированным глазом, зачастую, даже после применения достаточно агрессивных
техник оптимизации.

Вместе с тем, разработчики Stellar не принуждают конечных пользователей к такой
же суровой аскезе при разработке контрактов Soroban, развёртываемых в блокчейне.
Да, при коммуникации с внешней средой (платформой и другими контрактами)
программисту приходится ограничиваться классическим мономорфным FFI с небольшим
списком разрешённых базовых типов, что с точки зрения верификации, опять же,
является существенным плюсом. Однако, официальный SDK написан на Rust-е, так что
внутри самого контракта каждый волен городить произвольно сложные абстракции без
существенных препятствий. При этом, благодаря изолированной среде исполнения
WebAssembly и отсутствию разделяемого состояния с инфраструктурой и другими
контрактами, программист может не беспокоиться о разрушении каких-либо гарантий
надёжности, предоставляемых платформой.

Напрямую сравнивать платформы Polkadot и Stellar не очень честно, поскольку
первая, помимо базовой блокчейн-инфраструктуры предлагает пользователю богатый
ассортимент готовых инженерных решений на все случаи жизни, тогда как вторая
явно открещивается от ответственности за все вопросы бизнес-логики - обычно
функциональность, находящаяся на расстоянии одного включения готового паллета из
Substrate, в Soroban-е предполагается к реализации самим пользователем в виде
контрактов на основе примеров из отдельного репозитория. Однако, сложно,
всё-таки, не заметить, насколько сильно влияют архитектурные решения на
перспективы формальной верификации. Да, 500k строк C/C++ - тоже немало, и полная
верификация проекта, по-видимому, встала бы в один ряд с такими уникальными
достижениями как seL4 и CompCert, но успех реализации этого предприятия хотя бы
можно вообразить!

# Arbitrum Stylus

Третий проект, попавший в фокус нашего внимания, занимает промежуточное, в
некотором роде, положение с точки зрения потенциальной верифицируемости между
полярно различными подходами первых двух. В качестве основного языка разработки
тут выступает Go - чуть менее приближенный к ассемблеру по сравнению с
классической парой C/C++ за счёт более сложного рантайма с нативной поддержкой
лёгких тредов, но не так активно опирающийся на продвинутые средства
метапрограммирования и сложную типизацию как Rust. За счёт, по-видимому, большей
выразительности конкуррентного стиля горутин при обслуживании сетевых
взаимодействий, ядро Nitro даже компактнее Stellar - ~200k строк вместе с
Rust-овским клеем. Необходимо, однако, заметить, что центральное преимущество
данной платформы - бесшовная интероперабельность с сетью Ethereum - достигается
включением в состав проекта полномасштабной релизации соответствующего протокола
на Go, добавляющей на чашу весов ещё 400k строк.

Следует также понимать, что при оценке сложности формальной верификации на
уровне исполняемых бинарников, строки строкам рознь. Выразительная сила Go, увы,
отнюдь не бесплатна - обеспечивающая нативную конкуррентность
рантайм-инфраструктура мало того, что сама становится дополнительной целью для
верификации с достаточно сложной семантикой, так ещё и создаёт дополнительный
слой абстракции между исходным кодом и ассемблерным листингом, затрудняющий их
прямое сопоставление.

Ещё одним архитектурным решением, несколько усложняющим верификацию, приходится
признать выбор распределённого реестра EVM в качестве модели персистентности.
Мотивация здесь вполне понятна, поскольку интероперабельность с самой
популярной, на данный момент, платформой для смарт-контрактов - огромное,
очевидно, преимущество. Увы, эта конструкция криптографического леджера
популярна в силу скорее исторических причин, нежели архитектурных достоинств -
она смешивает до неразделимости бизнес-логику контракта и механизм достижения
консенсуса. Чтобы заметить насколько это всё усложняет, достаточно, опять же,
взглянуть для сравнения на реализацию персистентности без оглядки на легасив в
Stellar - там контракт, полностью изолированный наедине с собственными данными,
вообще не озабочен вопросами индексации своего состояния в глобальном trie.
При таком подходе бизнес-логика строго, на уровне изоляции в WebAssembly,
отделяется от всех инфраструктурных вопросов, что, конечно же, сильно облегчает
как её специфицирование, так и верификацию.

В свете вышесказанного, полная верификация рантайма Arbitrum издали
представляется всё же более сложной задачей в сравнении с аналогичным
мероприятием для Stellar, но, можно надеяться, всё ещё в пределах возможного.

# Фокусируемся на главном

Вернёмся, однако, с небес на землю и поговорим о ближней перспективе. По вполне
понятным причинам, инструменты, строящиеся на действительно инновационных
принципах, опрометчиво сразу пытаться применять к строительству дворцов -
здравый смысл подсказывает сперва потренироваться на небольших коттеджах. Даже
самый благоприятный из рассмотренных объектов - ядро Stellar - в этой аллегории
не меньше Эрмитажа. Неизбежно встаёт вопрос - а как бы так сузить план работ,
чтобы получить более плавную по масштабу кривую входа? Ответ напрашивается сам
собой - общеизвестно, что в метрике суммарного финансового ущерба уязвимости
бизнес-логики контрактов тотально доминируют над уязвимостями самих
блокчейн-платформ. Так почему бы не отложить пока вопросы надёжности
инфраструктуры, попытавшись сконцентрироваться на одной только бизнес-логике?

По самой природе DeFi, бизнес-логика каждого блокчейна неизбежно должна
распадаться на строго изолированные атомарные транзакции со строго определённой
семантикой взаимодействия, соответствующие несложным, по большей части,
бухгалтерским операциям. Обслуживающие эти транзакции контракты, таким образом,
могут выступать в роли естественной тренировочной мишени для обкатки новых
технологий верификации. При рассмотрении с этого ракурса картина в целом
меняется только масштабом:

1. Polkadot Substrate, никак не обособляющий бизнес-логику от инфраструктуры,
выглядит самой, с большим запасом, "трудной" мишенью. Бухгалтерские паллеты
отличаются от системных только по смыслу и после сборки в единый монолит покрыть
их формальной спецификацией можно даже не пытаться. Получить хоть чего-то
стоящие гарантии надёжности в такой ситуации можно, только ограничившись
верификацией контрактов Ink!, написанных в полностью самодостаточной манере,
с опорой лишь на строго ограниченное подмножество системных паллетов. Это не
снимает проблему перемежения бухгалтерских операций с инфраструктурой целиком, и
такой подход сложно назвать конвенциональным способом использования Substrate,
но увы, он пока выглядит единственным перспективным с точки зрения формальной
верификации бизнес-логики.

2. Stellar Soroban снова выглядит эталоном верифицируемости - бизнес-логика и
инфраструктура строго разделены вдоль физических границ песочницы WebAssembly,
транс-граничные интерфейсы просты до неприличия, механизм консенсуса полностью
абстрагирован. Исполняемый модуль контракта состоит только из бизнес-логики,
буквально 0-оверхед.

3. Arbitrum Stylus опять где-то посередине - от лишнего оверхеда явно честно
пытались избавиться, но увы, модель персистентности EVM задаёт непреодолимую
нижнюю планку сложности.

В такой постановке масштаб затеи уже перестаёт пугать - относительная
компактность и изолированность объектов рассмотрения позволяет
экспериментировать с подходами без опасений увязнуть в частностях. С контрактами
Soroban работать можно будет начать сразу после получения функционирующего MVP,
и даже Polkadot переходит из категории немыслимого в категорию "непросто, но
возможно".

# Серебряная пуля

Так как же устроен этот необычный новый инструмент, возможности которого мы
рассчитываем вскоре продемонстрировать на полигоне верификации смарт-контрактов?
Он состоит из трёх основных компонентов:

1. Компилятора `infc` для инновационного языка высокого уровня Inference,
сочетающего семантическую "прозрачность" C/C++, более привычный современным
разработчикам Rust-подобный синтаксис и уникальный, на данный момент,
ингридиент - управляемый недетерминизм в сочетании с квантификаторами для
генерализации высказываний о вычислениях. Этот язык позволит формулировать в
единообразном синтаксисе как исходный код самого контракта, так и его
полноценную формальную спецификацию с выразительной силой логик высшего порядка.

2. Механизации стандарта WebAssembly в интерактивном решателе теорем Rocq,
усиленной новым формализмом - дефинитивным интерпретатором, доказанно изоморфным
индуктивному определению операционной семантики. Использование такого
интерпретатора в качестве базовой тактики позволит, фактически, превратить
интеракивный режим Rocq в полноценную среду для символических вычислений в
семантике WebAssembly.

3. Математической теории, также механизированной в Rocq, позволяющей обобщить
любой дефинитивный интерпретатор до целого языка тактик, с помощью которого
доказательства свойств, сформулированных в спецификациях нашей новой парадигмы,
можно будет производить с невиданным ранее уровнем комфорта, полностью
абстрагируясь от всех несущественных деталей анализируемого кода.

Хочется надеяться, что, обкатав эти инновации в песочнице смарт-контрактов, в
будущем мы сможем отмасштабировать наш подход и для повышения надёжности самих
платформ - принципиальных, во всяком случае, препятствий этому пока не
наблюдается.