# Молоток в поисках гвоздей

В процессе разработки нового инструмента в какой-то момент неизбежно возникает
вполне резонная потребность испытать его за пределами собственной мастерской, в
неконтролируемой среде реальных задач. Наш инновационный фреймворк для
специфицирования и верификации программ **Inference** как раз подходит к этой
стадии, побуждая своих создателей примерять сей футуристичный молоток к каждому
встречному гвоздю. Однако, поскольку часов в сутках только 24, а проектов на
гитхабе, к которым, в теории, можно было бы приложить формальные методы,
существенно больше, чем имеет смысл считать, приходится каким-то образом
фильтровать потенциальный фронт работ.

По очевидным причинам, когда речь идёт о способах повышения надёжности программ,
фокусировать внимание разумно на проектах с более высокой ценой ошибки, так что
блокчейн-платформы неизбежно оказываются в начале списка - ущерб от нештатныч
ситуаций в крипто-финансовой индустрии почти всегда имеет прямую монетарную
оценку, среднее значение которой из года в год только растёт. В качестве второго
естественного критерия отсева выступает технологический стек - опытным полигоном
для нашей технологии стала механизация стандарта WebAssembly. Таким образом,
шорт-лист "гвоздей", подходящих нашему "молотку" на текущем этапе, можно
составить из блокчейн-платформ, использующих WebAssembly в качестве основного
таргета компиляции. В рамках этого разговора мы затронем три таких проекта:
Polkadot Substrate, Stellar Soroban и Arbitrum Stylus.

При взгляде на эту троицу издали в глаза бросается некоторое поверхностное
родство - все они используют Rust в качестве основного языка разработки, а
платформа WebAssembly является фундаментом их рантайма. Однако, при более
пристальном рассмотрении через оптику формальной верифицируемости начинают
проявляться фундаментальные архитектурные отличия, о которых мне и хотелось бы
здесь поговорить.

# Polkadot Substrate

Фреймворк за авторством Web3 Foundation представляет собой непрерывно
пополняющуюся коллекцию готовых решений для основных паттернов криптофинансового
учёта, организованную в виде собрания модулей специальной структуры
(`pallet`-ов) на языке Rust. Высокотехнологичная система сборки позволяет
комбинировать эти модули произвольным образом, производя тем самым на свет новые
версии рантайма, содержащие только необходимую для каждого отдельного случая
функциональность. Основные архитектурные принципы коллекции можно попытаться
сформулировать следующим образом:

1. `pallet` как универсальная единица интеграции. Любая функциональность,
которая может понадобиться блокчейн-разработчику, от отдельных аспектов
инфраструктуры до популярных паттернов бизнес-логики, предоставляется в виде
единообразно подключаемых модулей.

2. Активное использование Rust-овской системы типов и продвинутых средств
метапрограммирования в горизонтальном взаимодействии модулей для максимально
комфортного и безопасного переиспользования кода.

3. Большое внимание к оптимизации производительности рантайма с применением
наиболее мощных методик. Агрессивный инлайнинг на этапе LTO - настройка "по
умолчанию" при сборке конечного бинарника.

Сперва может показаться, что перечисленные выше качества - хвалебная ода, но, к
сожалению, у подобной архитектуры есть тёмная сторона, неизбежно вытекающая из
той же комбинации факторов, что создают её достоинства. И в тени этой, увы,
скрываются проблемы, способные, фактически, поставить крест на применимости
целого класса методов формально удостовериться в надёжности системы как в целом,
так и по частям.

Когда речь идёт о методологическом эталоне формальных методов - верификации
исполняемых бинарных модулей на уровне семантики машинного кода - от любой
достаточно крупной кодовой базы, подлежащей верификации, требуется ряд свойств,
о которых обычно программисты беспокоятся редко. Возникают эти требования в
связи с фундаментальными принципами рассуждений об алгоритмах и являются, по
факту, обязательными:

1. Сложные системы не верифицируемы целиком. Единственный практический способ
верификации сложных систем состоит в разбиении их спецификации на максимально
изолированные друг от друга подсистемы, верифицируемые независимо друг от друга.

2. Затраты на верификацию растут пропорционально квадрату количества подсистем,
делящих общее пространство состояний. Без чётко очерченных границ "владений",
нерушимость которых обеспечивается на уровне платформы, при верификации
приходится исходить из презумпции взаимного влияния всех на всех.

3. 
