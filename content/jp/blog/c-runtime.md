+++
title = 'Cランタイムを理解する'
date = 2025-01-15T11:21:45+09:00
draft = false
math = "katex"
summary = "Cランタイム（CRT）は、プログラムが実行されるために必要な初期化ルーチン、ライブラリのサポートコード、システムコールのラッパなどをまとめた仕組みです。本記事では、CRTのスタートアップオブジェクトに含まれる `crt0.o`、`crt1.o`、`crti.o`、`crtn.o` などのファイルがどのような役割を持ち、なぜ存在するのか、そしてC（およびC++）プログラムがスムーズに動作するためにどのように連携しているのかを解説します。"
tags = ["Clang", "Compilers", "アルゴリズム"]
aliases = ["/blog/c-runtime"]
+++

**目次**

- [はじめに](#はじめに)
- [Cランタイムとは何か](#cランタイムとは何か)
- [`crt0.o`（あるいはモダンツールチェーンにおける `crt1.o`）の役割](#crt0oあるいはモダンツールチェーンにおける-crt1oの役割)
  - [`crt0.o` / `crt1.o` の典型的な内容](#crt0o--crt1o-の典型的な内容)
  - [リンクフェーズ](#リンクフェーズ)
- [追加のランタイムファイル：`crti.o`、`crtn.o` など](#追加のランタイムファイルcrtiocrtno-など)
  - [`crti.o`: Cランタイム初期化](#crtio-cランタイム初期化)
  - [`crtn.o`: Cランタイム終了処理](#crtno-cランタイム終了処理)
- [全体的な流れ](#全体的な流れ)
- [アセンブリコードの例](#アセンブリコードの例)
- [モダンな使用法における注意点](#モダンな使用法における注意点)
- [結論](#結論)
- [参考文献](#参考文献)

---

## はじめに

以下のようなシンプルなCプログラムを例にとってみましょう：

```c
#include <stdio.h>

int main(void) {
    printf("Hello, world!\n");
    return 0;
}
```

このプログラムを `gcc hello.c -o hello` のようにコンパイルすると、表面上は `main()` 関数がプロセスの最初に実行されるように思えます。しかし実際には、プログラムが起動して環境を整える段階で、*`main()` の前後*に実行される特別なコード群が存在します。これらのコードはCランタイム（CRT）のスタートアップオブジェクトに含まれており、**`crt0.o`**、**`crt1.o`**、**`crti.o`**、**`crtn.o`** といったファイル名で見かけることがあります。本記事では、これらのファイルがどのような役割を持ち、なぜ存在するのか、そしてC（およびC++）プログラムがスムーズに動作するためにどのように連携しているのかを解説します。

## Cランタイムとは何か

Cランタイム（CRT）は、プログラムが実行されるために必要な初期化ルーチン、ライブラリのサポートコード、システムコールのラッパなどをまとめた仕組みです。これらの多くはユーザーが書くソースコードの外側にあり、コンパイラ（たとえば `gcc` や `clang`）が自動的にリンクしてくれます。

以下のコマンドのように、プログラムをコンパイルした場合：

```bash
gcc main.c -o main
```

または

```bash
clang main.c -o main
```

コンパイラドライバとリンカは、CRTのオブジェクトファイルやライブラリを*暗黙的*に含めます。これらのファイルには、アセンブリレベルのエントリポイントや以下のようなルーチンが含まれています。

1. レジスタやスタックの初期化  
2. プログラム引数（`argc`、`argv`、`envp`）のセットアップ  
3. （C++ の場合）グローバルコンストラクタの呼び出し  
4. ユーザーが書いた `main()` 関数の呼び出し  
5. `main()` 関数の返り値をOSに渡して終了させる処理

## `crt0.o`（あるいはモダンツールチェーンにおける `crt1.o`）の役割

従来、**`crt0.o`**（Cランタイム“ゼロ”）はプログラムの実際のエントリポイント（しばしば `_start` と呼ばれるルーチン）を含む小さなオブジェクトファイルとして存在していました。その主な役割は次のとおりです。

1. **プログラムの初期化**  
   - （必要に応じて）スタックの初期化  
   - メモリセグメント（データセクションやBSS領域など）のセットアップ  
   - カーネルから受け取る `argc`、`argv`、環境変数などの受け渡し準備  
   - グローバル・スタティックオブジェクト（特にC++で重要）のコンストラクタ呼び出し  
   - 標準ライブラリの初期化（標準I/Oなど）

2. **`main()` への制御移譲**  
   - 環境が整った後、`crt0.o` は `main(argc, argv, envp)` を呼び出します。

3. **終了処理**  
   - `main()` がリターンすると、`crt0.o` あるいは最後の終了ルーチンがOS特有のシステムコール（例：`_exit` など）を呼び出して、戻り値をプロセスの終了コードとして渡します。

**`crt0.o`** は一枚岩的なファイルであったため、近年のツールチェーンではよりモジュール化が進み、**`crt1.o`** という別の名前のファイルが使われることが多くなりました。名前は違っても、本質的な役割は同じで、リンカによってデフォルトのエントリポイント `_start` が組み込まれます。

### `crt0.o` / `crt1.o` の典型的な内容
- ランタイム初期化のための低レベルアセンブリコード
- リンカによって参照される `_start`（または `__start`）シンボル
- `main()` （または `_main`）を呼び出すルーチン

### リンクフェーズ
リンク時には、Cライブラリ（例：glibc、musl）やコンパイラツールチェーンから `crt0.o`（または `crt1.o`）が自動的にリンクされます。`-nostartfiles` のような特殊なフラグを使わない限り、ユーザーが意識しなくても常に含まれます。

## 追加のランタイムファイル：`crti.o`、`crtn.o` など

近年のツールチェーンでは、Cランタイムが以下のように複数のオブジェクトファイルに分割されることが一般的です。

- **`crti.o`**（Cランタイム初期化）  
- **`crtn.o`**（Cランタイム終了処理）  
- **`crt1.o`**（Cランタイムのエントリポイント）

### `crti.o`: Cランタイム初期化

**`crti.o`** には、ランタイム初期化における“プロローグ”部分が含まれます。主なタスクは次のとおりです。

- **プラットフォーム固有の初期化**  
  特殊レジスタやCPU機能の初期化、あるいはアーキテクチャ依存の設定など  
- **環境の準備**  
  C++ であれば `.ctors` セクションのコンストラクタ呼び出しを行うための下準備  
- **早期セットアップのフック**  
  OSやプラットフォームに特有の初期ルーチン（例：スレッドローカルストレージ（TLS）の準備）

`crti.o` は「これからランタイムを始動するので、まずはプロローグを実行する」というイメージです。最終的には `main()` など実行時の本体へ制御が移ります。

### `crtn.o`: Cランタイム終了処理

**`crtn.o`** には、初期化の“エピローグ”部分と終了時の後処理が含まれます。具体的には次のような作業を行います。

- **初期化シーケンスの完了**  
  `crti.o` が開始した初期化を完結させ、すべてのグローバルコンストラクタが呼び出されたことを保証  
- **デストラクタの管理**  
  C++ の場合、グローバルデストラクタ（`.dtors` セクション）がプログラム終了時に正しく呼ばれるようにする

プログラムが終了するとき、グローバルオブジェクトのデストラクタを呼び出し、必要なリソースがクリーンアップされてから実際に終了（OSに制御が戻る）します。

## 全体的な流れ

これらのファイルがどのように連携してプログラムを開始・終了させるのかを、簡単なフローチャートに示します。

```
        ┌─────────────────────┐
        │ Program Entry Point │  (Defined in crt1.o or crt0.o)
        │     _start()        │
        └──────────┬──────────┘
                   │
                   │ (1) Initialize environment, memory, etc.
                   │
        ┌──────────┴──────────┐
        │   crti.o (Prologue) │
        │  Calls constructors │
        └──────────┬──────────┘
                   │
                   │ (2) Jump to main()
                   │
        ┌──────────┴──────────┐
        │        main()       │
        └──────────┬──────────┘
                   │
                   │ (3) main returns
                   │
        ┌──────────┴──────────┐
        │   crtn.o (Epilogue) │
        │  Calls destructors  │
        └──────────┬──────────┘
                   │
                   │ (4) exit syscall
                   │
             ┌─────┴──────┐
             │   OS Exit  │
             └────────────┘
```

**ポイント**:  
1. `_start`（`crt0.o` または `crt1.o` に含まれる）が低レベルの初期化を行い、その後 `crti.o` のプロローグコードを呼び出します。  
2. `crti.o` で初期化が終了すると、`main()` へジャンプします。  
3. `main()` が終了すると、`crtn.o` のエピローグが呼び出され、グローバルデストラクタなどが処理されます。  
4. 最後に、システムコールによってプロセスを終了させ、`main()` のリターン値をOSに返却します。 

## アセンブリコードの例

以下は、Linux x86-64 における `_start` ルーチンの*最簡易的*な例です（実際の `crt1.o` や `crt0.o` はもっと複雑です）。本番環境では、環境変数の管理やスレッドローカルストレージなど、より多くの仕組みが含まれます。

```asm
    .global _start
_start:
    ; The stack pointer is already set by the OS.
    ; Registers RDI, RSI, and RDX might have pointers to argc, argv, and envp.

    ; Save argc, argv, and envp to the stack, or
    ; pass them to main() directly (depending on calling convention).
    mov rdi, [rsp]               ; argc is at top of stack
    lea rsi, [rsp+8]             ; argv pointer just after argc
    ; envp would be after argv, etc.

    call main                    ; Call main(argc, argv, envp implicitly)

    ; Capture return code in eax
    mov rax, rax

    ; Make an exit system call
    mov rax, 60                  ; sys_exit on Linux x86-64
    syscall
```

続いて、非常にシンプルな `crti.o` の例（C++向け擬似コード/アセンブリ）を示します：

```asm
    .section .init
    _init:
        ; グローバルコンストラクタを初期化するなど、
        ; ランタイムが main を呼び出す前に必要な処理を実行。
        ; 例えば __libc_init_array を呼び出す場合もある。
        ret
```

さらに、`crtn.o` は対になる以下の例を持ちます：

```asm
    .section .fini
    _fini:
        ; 終了時のクリーンアップとグローバルデストラクタの呼び出しを行う。
        ; 例えば __libc_fini_array を呼び出す場合もある。
        ret
```

実際のツールチェーンでは、GNUリンカスクリプトや `.init_array` / `.fini_array`、あるいは `.ctors` / `.dtors` を利用し、`main()` の前後でこれらのコードを自動的に実行します。

## モダンな使用法における注意点

- **静的リンクと動的リンク**  
  `-static` フラグを用いて静的リンクを行うと、CRTのファイルは最終的なバイナリにすべて含まれます。動的リンクする場合は、これらのCRTオブジェクトが動的ローダとの連携を担当し、必要なライブラリをロードした後に `main()` を呼び出します。

- **OSによる実装差**  
  Linux（glibc や musl）では `crt1.o`、`crti.o`、`crtn.o` などがよく見られますが、BSD系やmacOSなどでは名称やプロセスが異なる場合があります。

- **C++ におけるコンストラクタ／デストラクタ**  
  `.ctors` や `.dtors`、あるいは `.init_array` と `.fini_array` は、グローバルオブジェクトのコンストラクタとデストラクタを自動的に呼び出す仕組みです。`crti.o` と `crtn.o` はこれらの呼び出しをラップして、プログラム開始前と終了時に正しく処理させます。

- **カスタムエントリポイント**  
  `-nostdlib` や `-nostartfiles` などを使って標準CRTをリンクせずに独自のエントリポイントを用意することも可能です（組込みシステムやブートローダなど）。

## 結論

Cランタイム（CRT）は、CやC++プログラムを起動するうえで非常に重要でありながら、普段はあまり意識されない部分です。**`crt0.o`**（あるいは **`crt1.o`** や **`crti.o`**、**`crtn.o`**）は、`main()` が実行される前にスタックやグローバルコンストラクタ、ライブラリなどのセットアップを行い、実行が終了したあともデストラクタなどを呼び出して最後の後始末をします。コンパイラが自動的にリンクしてくれるためユーザーは通常意識しませんが、この仕組みを知ることで、C/C++アプリケーションがどのように動作を開始し、どのように終了へ至るのかをより深く理解することができます。

組込み開発やコンパイラの開発を行う場合はもちろん、Cの仕組みについて学びたいという方にとっても、Cランタイムの概要を把握しておくことは大きな意味を持ちます。`main()` 関数の“見えない裏側”を理解することで、プログラムの起動プロセスや終了プロセスの本質を明らかにできるでしょう。

## 参考文献

- [GNU C Library (glibc) Source][1]  
  `crt1.o`、`crti.o`、`crtn.o` などが *sysdeps* ディレクトリで確認できます。
- [musl C Library][2]  
  よりシンプルな実装で、CRTファイルの構造を把握しやすいです。
- [GCC Documentation][3]  
  スタートアップファイル、リンク、ランタイム関連の資料があります。
- [The Open Group Base Specifications Issue 7][4]  
  標準化されたプロセスインターフェイスや環境の詳細を解説。

[1]: https://sourceware.org/git/?p=glibc.git
[2]: https://musl.libc.org/
[3]: https://gcc.gnu.org/onlinedocs/
[4]: http://pubs.opengroup.org/onlinepubs/9699919799/

{{<post-socials language="jp" page_content_type="blog" telegram_post_id="23">}}
{{<ai-translated>}}
