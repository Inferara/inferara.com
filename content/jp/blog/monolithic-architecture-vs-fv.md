+++
title = "モノリシックアーキテクチャ vs 形式検証：組み合わせ爆発の問題"
date = 2026-01-14T15:56:00+09:00
draft = false
math = "katex"
summary = "モノリシックアーキテクチャは、検証の複雑さにおける組み合わせ爆発を引き起こします。モジュラー境界はこの増大を抑制し、バイトコードレベルの形式検証を実現可能なものにします。"
tags = ["アーキテクチャ", "形式検証", "Stellar", "Polkadot", "Arbitrum"]
aliases = ["/blog/monolithic-architecture-vs-fv"]
+++

# **釘を探すハンマー**

![alt text](/img/monolithic-architecture-vs-fv/hammer%20in%20search%20of%20nails.png)

新しいツールを開発する過程において、ある時点で自分の作業場（ワークショップ）から出て、制御されていない現実世界の環境でそれをテストしたいという妥当な欲求が必然的に生じます。[**Inference**](https://inference-lang.org/)と呼ばれる、プログラムの仕様記述と検証のための私たちの革新的なフレームワークは、まさにこの段階に差し掛かっています。開発者である私たちに対し、この未来的なハンマーを、目につくすべての釘に対して試してみるよう促しているのです。しかし、1日は24時間しかなく、GitHub上で理論的に形式手法を適用できるプロジェクトの数は、数える意味がないほど膨大であるため、潜在的な作業領域を何らかの方法でフィルタリングする必要があります。

当然の理由として、ソフトウェアの信頼性を向上させる方法を議論する場合、エラーの代償が高いプロジェクトに焦点を当てるのが賢明です。ブロックチェーンプラットフォームは必然的にリストのトップに来ます。なぜなら、暗号資産（クリプト）業界における緊急事態による損害は、ほぼ常に直接的な金銭的評価を伴い、その平均額は増加の一途をたどっているからです。第二の自然淘汰の基準は技術スタックです。WebAssembly標準の自動化（機械化）は、私たちの技術の実験的なテスト場となりました。したがって、現段階で私たちのハンマーに適した「釘」のショートリストは、コストを担う目的でWebAssemblyをターゲットとするブロックチェーンプラットフォームで構成できます。本記事では、そのような3つのプロジェクト、Polkadot Substrate、Stellar Soroban、そしてArbitrum Stylusについて触れます。

遠くからこの3つを眺めると、いずれもコントラクト開発の主要言語の一つとしてRustを使用し、ランタイムの基盤としてWebAssemblyプラットフォームを採用しているため、ある種の表面的な類似性が目に留まります。しかし、形式検証可能性（formal verifiability）というレンズを通して詳しく調べると、根本的なアーキテクチャの違いが明らかになり始めます。ここではそれについて議論したいと思います。

# **Polkadot Substrate**

![alt text](/img/monolithic-architecture-vs-fv/Polkadot_Logo_Pink-Black.png)

Parity Technologiesが開発したこのフレームワークは、主要な暗号金融会計パターンのための既製ソリューションの継続的に拡張されるセットであり、Rust言語による特別な構造を持ったモジュール（パレット）のコレクションとして構成されています。ハイテクなビルドシステムにより、これらのモジュールを任意に組み合わせることができ、それによって個々のケースに必要な機能のみを含む新しいバージョンのランタイムを生成できます。このコレクションの主要なアーキテクチャ原則は次のように定式化できます。

1. **統合の普遍的な単位としてのパレット：** インフラストラクチャの個々の側面から一般的なビジネスロジックパターンまで、ブロックチェーン開発者が必要とする可能性のあるあらゆる機能が、均一に接続されたモジュールの形式で提供されます。
2. **Rustの型システムと高度なメタプログラミングツールの積極的な使用：** 最も快適かつ安全なコード再利用を実現するために、モジュール間の水平的な相互作用においてこれらが活用されます。
3. **ランタイムのパフォーマンス最適化への多大な注力：** 最も強力な技術を使用し、最終的なバイナリをビルドする際のデフォルト設定として、リンク時最適化（LTO）段階での積極的なインライン化（Aggressive inlining）が行われます。

一見すると、上記の性質は称賛に値するように思えますが、残念ながら、このようなアーキテクチャには暗部（ダークサイド）もあります。それは、その利点を生み出すのと同じ要因の組み合わせから必然的に生じるものです。これらの恩恵の影には、悲しいことに、システム全体および部分の信頼性を形式的に保証するための手法全体の実現可能性を事実上終わらせてしまう問題が潜んでいます。

形式手法の方法論的なベンチマーク、つまりプラットフォームのセマンティクス（意味論）レベルでの実行可能なバイナリモジュールの検証について議論する場合、検証対象となる十分に大きなコードベースには、プログラマが通常ほとんど気にしない一連の特性が要求されます。これらの要件は、アルゴリズムに関する推論の基本原則に関連して発生し、事実上必須のものです。

1. **複雑なシステムは、その全体を検証することはできない：** 複雑なシステムを検証する唯一の実用的な方法は、システムを分解し、互いに可能な限り分離されたサブシステムを仕様化し、それらを互いに独立して検証することです。
2. **総検証コストは、共通の状態空間を共有するサブシステムの数の二乗に比例して増加する：** プラットフォームレベルで整合性が保証された「ドメイン」の境界が明確に定義されていない場合、検証は「全てが全てに影響し合う」という推定に基づかなければなりません。
3. **アルゴリズムの特性に関する判断を再利用することは、アルゴリズム自体を再利用するよりもはるかに難しい：** モノモーフィゼーション（単相化）とインライン化は、開発者やエンドユーザーにとっては事実上無料ですが、形式検証の文脈では非常にコストがかかります。なぜなら、これらの手順によって生成されたコードのコピーはすべて、独立したカバレッジを必要とする別個のターゲットとなるからです。

この観点から見ると、FRAMEアーキテクチャは残念ながら、事実上あらゆる場面で形式検証のタスクを複雑にすることを選択していることが突然明らかになります。確かに、ソースコードレベルでは、パレットシステムは柔軟性、モジュール性、使いやすさを発散しています。しかし、Rustのソースコードの完全な形式検証は（単にそのセマンティクスの公式仕様が存在しないため）長い間ユートピア的な夢のままでしょう。一方で、実行可能なバイナリのレベルでは、状況ははるかに悲惨です。

![alt text](/img/monolithic-architecture-vs-fv/blog1.svg)

中心的な問題は、ソースコードモジュール間のすべての構造的境界が、コンパイルプロセスのかなり早い段階で完全に消去されてしまうことです。実際、あるパレットから別のパレットへのマクロ定義を使用する機能は、プリプロセス段階でさえもそれらを侵食します。最終結果、たとえば公式のPolkadotランタイムを逆アセンブルしてみると、その結果は200万以上の命令を持つ単一の巨大な（モノリシックな）モジュールとなり、特定のパレットに明確に割り当てることができる関数はごく稀です。さらに悪いことに、この生成物の中心には、プロジェクトのあらゆる場所から集められた完全に異質なコード片が無数に自動インライン化され、中央イベントディスパッチャの本体に直接埋め込まれた、数十万行に及ぶ単一の関数が横たわっています。

残念ながら、このような作業課題に直面したとき、形式検証エンジニアができる唯一のことは、お手上げ状態になることだけです。なぜなら、現時点でこのような条件下で正しさを仕様化し証明することは、技術的にほぼ不可能であり、経済的にも不合理だからです。奇跡的に、特定のバージョンのPolkadotランタイムに対して包括的で厳密に証明された仕様を作成できたとしても、この成果は、含まれるパレットの構成が異なる派生フォークだけでなく、Polkadot自体の後続バージョンにさえ完全に適用できません。さらに、Dockerサンドボックスを使用してもRustのビルドプロセスに信頼性の高い決定性がないことを考慮すると、単に別のマシンでバイナリを再コンパイルするだけで無効になることもあります。並列コンパイル中のスレッド競合（どうやらこれが原因のようです）により、共有メモリのアドレス空間と関数の順序インデックスが完全に自由に混ざり合ってしまうからです。

アーキテクチャの根本的な見直しを行わずに、少しの努力で上記の問題をどうにか補うことは可能でしょうか？この分野の進歩がいかに速いかを考えると、これは難しい質問です。数年後には、LLMを使用した検証の自動化によって、すべてのスケーリングの問題に対して大量のGPUリソースを投入するだけで解決できるようになるかもしれません。しかしそれまでは、見通しは残念ながら期待薄です。Polkadotのコードベースを継承するランタイムについて、それがデプロイされ実行される形での正しさの形式的な確認を得ようとする試みは、非現実的に思えます。ただし、これはユーザーや開発者が小規模な範囲で信頼性を向上させるために形式手法を適用することを妨げるものではありません。たとえば、重要な関数における非自明な算術演算は疑似コードレベルで検証できますし、別々のwasmモジュールにおけるコントラクトの分離により、少なくともそれらについてはアセンブラレベルでの検証を検討することができます。

# **Stellar Soroban**

![alt text](/img/monolithic-architecture-vs-fv/Stellar%20Logo%20Final%20RGB.png)

Substrateの次にこのプラットフォームに触れると、最初に目を引くのはその徹底的なミニマリズムです。暗号台帳（レジャー）の専用コアには、非常にオーソドックスなC/C++コードのサブセットがわずか50万行含まれているだけです。過剰なものはなく、ネットワークプロトコルの基本機能と、分散コンセンサスを実装するアルゴリズムのみが存在します。システムが機能するためにすべての関数が必要であるため、オプションのコンポーネントはありません。メタプログラミングやポリモーフィズムはほとんど使用されず、古典的な手続き型コードが、明確に定義されたデータ構造上で直接的に動作します。

> 「それは私たちの祖父や曾祖父がコードを書いていたやり方だ」

あなたはそう冗談を言うかもしれませんが、それは真実からそう遠くありません。実際、TCP/IPスタックの進歩と多少の芸術的な誇張を除けば、Stellarコアは90年代半ばのコンパイラを使用して、前世紀のメインフレーム用にコンパイルできたかもしれません。

しかし、このミニマリズムを時代遅れ（アルカイズム）と間違えるのは大きな間違いです。一部の開発手法が長年にわたってほとんど変わらないのは、ワニが進化しないのと同じ理由です。つまり、それらは生態学的ニッチに完全に適応しているからです。逆説的に聞こえるかもしれませんが、実行可能なバイナリのレベルで形式検証の対象となるシステムを計画している場合、明確に定義されたデータ構造を用いた直接的な操作という古典的な手続き型スタイルこそが、最良の（そしてシステムが成長するにつれて唯一の）チャンスとなります。

![alt text](/img/monolithic-architecture-vs-fv/Stellar-croc.jpg)

> 肥大化なし。適応済み。正統派。ニッチに特化。検証可能。

実のところ、この一見時代遅れな開発手法は、システム全体の検証可能性に影響を与える主要なパラメータ、すなわち「ソースコードとアセンブリリストの間の構造的距離」の観点から最適化されています。現代のプログラマが慣れ親しんでいる快適さと柔軟性を意識的に放棄することで、私たちはその代償として、アルゴリズムについて推論するための計り知れない利点を得ることができます。それは、プログラマが使用した言語のステートメントや式と、アセンブリプロセスから出力されるコンパクトなマシン命令のグループを、一行ずつ並置（対比）できる能力です。より洗練された現代のコンパイラの「ミートグラインダー（挽肉機）」の中で追加の抽象化レイヤーによって切り刻まれると完全に失われてしまう開発者の思考の明瞭さが、オーソドックスなC/C++の透明なコンパイルプロセスを通じて比較的損なわれずに残り、訓練された目であれば、かなり積極的な最適化技術を適用した後でも読み取ることができるのです。

同時に、Stellarの開発者は、ブロックチェーン上にデプロイされるSorobanコントラクトを開発する際、エンドユーザーにそのような厳格な禁欲主義を強制しません。確かに、外部環境（プラットフォームや他のコントラクト）と通信する場合、プログラマは許可された基本型の小さなリストを持つ古典的なモノモーフィックな外部関数インターフェース（FFI）に制限する必要がありますが、これは検証の観点からは再び大きな利点となります。しかし、公式SDKはRustで書かれているため、コントラクト自体の内部では、誰もが大きな障害なしに任意の複雑な抽象化を自由に構築できます。同時に、隔離されたWebAssembly実行環境と、インフラストラクチャや他のコントラクトとの共有状態が存在しないおかげで、プログラマはプラットフォームが提供する信頼性の保証を壊すことを心配する必要がありません。

PolkadotとStellarのプラットフォームを直接比較するのは完全に公平とは言えません。前者は基本的なブロックチェーンインフラストラクチャに加えて、あらゆる場面に対応する幅広い既製のエンジニアリングソリューションをユーザーに提供しているのに対し、後者はすべてのビジネスロジックの問題について責任を明確に放棄（線引き）しているからです。通常、Substrateの既製パレットに単純に含まれている機能は、Sorobanでは別のリポジトリの例に基づいてコントラクトの形でユーザー自身が実装することが期待されています。しかし、アーキテクチャの決定が形式検証の見通しにどれほど強く影響するかについては、気づかないわけにはいきません。確かに、50万行のC/C++も多い量であり、プロジェクトの完全な検証はseL4やCompCertのようなユニークな成果と並ぶことになるでしょうが、この試みの成功は少なくとも想像の及ぶ範囲にあります！

# **Arbitrum Stylus**

![alt text](/img/monolithic-architecture-vs-fv/0923_Arbitrum_Logos_Primary_horizontal_RGB.jpg)

私たちの注目を集めた3番目のプロジェクトは、最初の2つの対極的なアプローチの間で、潜在的な検証可能性の点で、ある意味中間的な位置を占めています。その検証可能性を理解するには、NitroホストとStylus実行環境を区別する必要があります。基盤となるノードソフトウェア（Nitro）は主にGoで書かれています。これは、Ethereum Gethクライアントのフォークとしての起源による選択です。Goはネットワーク相互作用やシーケンシングを処理するための優れた並行性を提供しますが、確かに複雑なランタイムとガベージコレクション（GC）のレイヤーをノードのインフラストラクチャに導入します。

Goは、軽量スレッドのネイティブサポートを備えたより複雑なランタイムのため、古典的なC/C++のペアよりもアセンブリ言語からわずかに遠いですが、Rustほど高度なメタプログラミングツールや複雑な型付けには依存していません。ネットワーク相互作用を処理する際のGoルーチンの並行スタイルの表現力が明らかに高いため、NitroコアはRustのグルーコード（接着コード）を含めても約20万行と、Stellarよりもさらにコンパクトです。ただし、このプラットフォームの中心的な利点であるEthereumネットワークとのシームレスな相互運用性は、対応するプロトコルのフルスケールの実装をGoに含めることで達成されており、これによりプロジェクトにさらに40万行が追加されることに注意する必要があります。

また、実行可能なバイナリのレベルで形式検証の複雑さを評価する場合、すべての行が平等に作られているわけではないことを理解する必要があります。Goの表現力は残念ながら無料ではありません。ネイティブな並行性を提供するランタイムインフラストラクチャは、かなり複雑なセマンティクスを持つ追加の検証ターゲットになるだけでなく、ソースコードとアセンブリリストの間に追加の抽象化レイヤーを作成し、直接的な整合（アライメント）を難しくします。

検証を幾分複雑にするもう一つのアーキテクチャ上の決定は、永続化モデルとしてのEVM分散台帳の選択です。現時点で最も人気のあるスマートコントラクトプラットフォームとの相互運用性が明らかに大きな利点であるため、ここでの動機は非常に明確です。残念ながら、この暗号台帳の設計は、アーキテクチャ上のメリットよりも歴史的な理由で人気があるようです。なぜなら、それは回避できたはずの、コントラクトのビジネスロジックとコンセンサスメカニズムの間のある程度の混在を必要とするからです。これがどれほど物事を複雑にするかを確認するには、比較のために、レガシーを考慮しないStellarでの永続化の実装を見るだけで十分です。そこでは、独自のデータで完全に隔離されたコントラクトは、グローバルなトライ（trie）における状態のインデックス付けに関与しません。このアプローチでは、ビジネスロジックはWebAssembly内の隔離レベルですべてのインフラストラクチャの問題から厳密に分離されており、これはもちろん、その仕様記述と検証の両方を大幅に容易にします。

上記に照らすと、Arbitrumのランタイムの完全な検証は、Stellarに対する同様の取り組みと比較して依然としてより困難なタスクであるように思われますが、うまくいけばまだ可能性の範囲内にあるでしょう。

# **本質への集中**

![alt text](/img/monolithic-architecture-vs-fv/cottage%20or%20palace.jpg)

しかし、世界征服の計画はしばらく置いておき、より狭い視点について話しましょう。十分理解できる理由から、真に革新的な原則に基づいて構築されたツールを、すぐに宮殿の建設に適用しようとするのは軽率です。常識的には、まずは小さなコテージで練習すべきだと示唆されます。検討されたオブジェクトの中で最も好条件なStellarコアでさえ、この寓話においてはルーヴル宮殿に劣らない規模です。規模の面でより緩やかな参入曲線を得るために、作業計画をどのように絞り込むことができるかという疑問が必然的に生じます。答えは明白です。金銭的被害の総額という指標において、コントラクトのビジネスロジックの脆弱性が、ブロックチェーンプラットフォーム自体の脆弱性を完全に圧倒していることは周知の事実です。では、インフラストラクチャの信頼性の問題はひとまず置いておき、ビジネスロジックのみに集中してみてはどうでしょうか？

DeFiの性質上、各ブロックチェーンのビジネスロジックは必然的に、主に単純な会計操作に対応する狭く定義された相互作用セマンティクスを持つ、厳密に隔離されたアトミックなトランザクションに分解されなければなりません。したがって、これらのトランザクションを提供するコントラクトは、新しい検証技術をテストするための自然なトレーニングターゲットとして機能します。この観点から見ると、全体像はスケールの面でのみ変化します。

1. **Polkadot Substrate**は、ビジネスロジックをインフラストラクチャから分離していないため、依然として圧倒的に最も困難なターゲットであるように見えます。会計パレットはシステムパレットと意味においてのみ異なり、単一のモノリスに組み込まれた後では、それらを形式仕様でカバーしようとさえすべきではありません。このような状況では、厳密に制限されたサブセットのシステムパレットのみに依存し、完全に自己完結した方法で書かれたInk!コントラクトの検証に限定することでしか、信頼性の価値ある保証を得ることはできません。これは会計操作とインフラストラクチャ全体が混在する問題を完全に解決するわけではなく、またそのようなアプローチはSubstrateの従来の使用方法とは言い難いですが、残念ながらビジネスロジックの形式検証に関しては、依然として唯一の有望な方法であると思われます。
2. **Stellar Soroban**は、ここでも検証可能性のベンチマークであるように見えます。ビジネスロジックとインフラストラクチャはWebAssemblyサンドボックスの物理的境界に沿って厳密に分離されており、境界を越えるインターフェースは極めて単純で、コンセンサスメカニズムは完全に抽象化されています。実行可能なコントラクトモジュールは、文字通りゼロオーバーヘッドのビジネスロジックのみで構成されています。
3. **Arbitrum Stylus**は、ここでも中間に位置します。彼らは明らかに過剰なオーバーヘッドを取り除こうとしましたが、残念ながらEVM永続化モデルが複雑さの越えられない下限を設定しています。

この文脈において、そのような取り組みの規模はもはや恐ろしいものではなくなります。検討中のオブジェクトの相対的なコンパクトさと分離性により、詳細に埋没することを恐れずにアプローチを実験することが可能になります。Sorobanコントラクトへの取り組みは、機能するMVPを受け取った直後から開始でき、Polkadotでさえ「考えられない」カテゴリーから「容易ではないが可能」なカテゴリーへと移行しつつあります。

# **銀の弾丸**

![alt text](/img/inference-logo.svg)

では、この一風変わった新しいツールはどのように機能するのでしょうか？ スマートコントラクトの検証をテスト場として使用し、まもなくその機能を実証したいと考えています。これは主に3つのコンポーネントで構成されています。

1. 革新的な高レベル言語 [**Inference**](https://inference-lang.org/) のための推論コンパイラ（`infc`）。これは、C言語の意味論的な透明性、現代の開発者にとってより馴染み深いRustライクな構文、そして計算に関する記述を一般化するための量化子と組み合わせた「制御された非決定性（controlled non-determinism）」というユニークな要素を兼ね備えています。この言語により、コントラクト自体のソースコードと、高階論理の表現力を持つその完全な形式仕様の両方を、統一された構文で定式化することが可能になります。
2. 対話型定理証明支援系 **Rocq** におけるWebAssembly標準の機械化（Mechanization）。これは新しい形式手法によって強化されています。それは、操作的意味論（operational semantics）の帰納的定義と同型であることが証明された**定義的インタプリタ（definitional interpreter）**です。このようなインタプリタを基本的なタクティク（戦術）として使用することで、事実上、対話型のRocqモードをWebAssemblyセマンティクスにおける記号計算（symbolic computation）のための本格的な環境へと変えることができます。
3. 同じくRocqで機械化された数学的理論。これにより、あらゆる定義的インタプリタをタクティクの言語全体へと一般化することが可能になり、私たちの新しいパラダイムの仕様で定式化された特性を、かつてないレベルの快適さで、分析対象コードの些細な詳細を完全に抽象化して証明できるようになります。

スマートコントラクトのサンドボックスでこれらのイノベーションをテストした後、将来的には私たちのアプローチをスケールアップし、プラットフォーム自体の信頼性を向上させることができると期待しています。私たちの理解では、現時点でこれに対する根本的な障害はありません。

