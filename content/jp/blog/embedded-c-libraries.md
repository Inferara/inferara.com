+++
title = "組込みシステムに適したCライブラリの選択：Newlib, picolibc, nanolib, dietlibc"
date = 2025-04-10T10:10:15+09:00
draft = false
math = "katex"
summary = "glibcのような標準ライブラリが大きすぎる、または複雑すぎるリソース制約環境向けに設計された、Newlib、picolibc、nanolib、dietlibcといった特殊なC標準ライブラリを解説します。"
tags = ["組込み", "libc", "コンパイラ", "最適化", "Clang", "Compilers"]
aliases = ["/blog/embedded-c-libraries"]
+++

**目次**

- [はじめに](#はじめに)
- [C標準ライブラリ（libc）とは？](#c標準ライブラリlibcとは)
- [標準的なデスクトップライブラリ（glibcなど）を使わない理由](#標準的なデスクトップライブラリglibcなどを使わない理由)
- [組込みシステム向けの代替ライブラリ](#組込みシステム向けの代替ライブラリ)
  - [Newlib](#newlib)
  - [picolibc](#picolibc)
  - [nanolib (Newlib-nano / nano.specs)](#nanolib-newlib-nano--nanospecs)
  - [dietlibc](#dietlibc)
- [主な違いの比較](#主な違いの比較)
- [Cランタイム（crt0）との連携](#cランタイムcrt0との連携)
- [プロジェクトに適したライブラリの選択](#プロジェクトに適したライブラリの選択)
- [まとめ](#まとめ)
- [参考文献](#参考文献)

## はじめに

[以前のCランタイムに関する投稿]({{< ref "/blog/c-runtime" >}})では、`main()`関数が呼び出される前に実行環境を準備する`crt0`、`crti`、`crtn`といった重要なスタートアップコンポーネントについて解説しました。これらのスタートアップファイルは、私たちが日常的に利用する`printf`、`malloc`、`strcpy`などの基本的な関数を提供する**C標準ライブラリ（libc）**と密接に連携して動作します。

デスクトップやサーバーシステムでは、一般的にglibc（GNU C Library）やMicrosoftのCRTのような包括的なライブラリが利用されます。しかし、組込みシステムの世界では特有の課題があります。リソースに制約のある環境では、メモリ（コード格納用のFlash/ROMと実行用のRAMの両方）に関する厳しい制限に直面することがよくあります。このような状況でフル機能のlibcを導入すると、貴重なリソースをすぐに消費してしまい、実用的ではありません。

この記事では、こうした制約のある環境向けに特別に設計または適合された、いくつかの人気のある代替Cライブラリ、**Newlib**、**picolibc**、**nanolib**、そして**dietlibc**について掘り下げていきます。それぞれの設計目標、長所、短所、典型的なユースケースを探り、簡単な例を交えて解説します。

## C標準ライブラリ（libc）とは？

C標準ライブラリ（しばしば「libc」と呼ばれる）は、C標準（ISO C99, C11, C17など）で定められた共通の操作を実装する、ヘッダファイル（`<stdio.h>`, `<stdlib.h>`, `<string.h>`など）と、それに対応するコンパイル済みコード（関数）の標準化されたコレクションです。

libcが提供する主な機能には以下のようなものがあります：
- 入出力（例：`printf`, `scanf`, `fopen`, `fread`）
- 文字列操作（例：`strcpy`, `strlen`, `strcmp`）
- メモリ管理（例：`malloc`, `free`, `calloc`）
- 数学関数（`<math.h>`経由の`sin`, `cos`, `sqrt`など）
- ユーティリティ関数（例：`atoi`, `exit`, `qsort`）

本質的に、libcはC言語を汎用的な言語たらしめている基本的なツールキットを提供し、多くの低レベルなオペレーティングシステムやハードウェアとのやり取りを抽象化します。

## 標準的なデスクトップライブラリ（glibcなど）を使わない理由

glibcのようなライブラリは強力で機能が豊富であり、広範なPOSIX準拠を目指し、多岐にわたる機能（国際化対応、高度なネットワーク機能、洗練されたスレッド管理など）をサポートしています。しかし、この包括性は多くの組込みシステムにとっては高すぎる代償を伴います：

1.  **サイズ:** glibcは、静的リンク時のバイナリサイズも、共有ライブラリとしてのサイズや実行時のメモリ使用量も大きくなります。これは、ギガバイト単位ではなくキロバイト単位のメモリしか持たないマイクロコントローラにとっては、しばしば受け入れがたいものです。
2.  **依存関係:** glibcは通常、仮想メモリ、ファイルシステム、複雑なプロセス管理といった機能を備えた完全なオペレーティングシステム環境（Linuxなど）を前提としています。これらはベアメタル環境やシンプルなRTOSには存在しません。
3.  **複雑性:** その複雑な内部構造は、ミニマリストな環境にとっては過剰であり、デバッグやカスタマイズが困難になる可能性があります。

組込みシステムでは、より軽量でモジュール化されており、基盤となるOS機能への依存が最小限であるライブラリが求められます。

## 組込みシステム向けの代替ライブラリ

これらのニーズに応えるために、いくつかのCライブラリが登場しました。ここでは代表的な4つのライブラリを見ていきましょう：

### Newlib

-   **起源:** Cygnus Solutions（現在はRed Hatの一部）によって開発されました。
-   **目標:** 組込みシステム（特に完全なOSがない「ベアメタル」環境やリアルタイムOS（RTOS）を使用する環境）に適した、ポータブルなオープンソースCライブラリを提供すること。
-   **主な特徴:** 高い移植性、良好なC標準準拠、設定可能な機能。重要な点として、**システムコール（syscall）スタブ**機構を使用します。OSやハードウェアとの対話が必要な関数（I/Oやヒープ管理など）は、**ユーザーがターゲットプラットフォームに合わせて実装しなければならない**、弱くリンクされたスタブ関数（例：`_read`, `_write`, `_sbrk`）を呼び出します。
-   **例（Syscallスタブの実装）:** ベアメタルシステム上でUART経由で`printf`を動作させるためには、次のように`_write`スタブを実装するかもしれません：

```c
#include <unistd.h> // STDOUT_FILENOなどに必要（環境による）
#include "my_uart_driver.h" // ハードウェア固有のUARTドライバ関数

// Newlib用の_writeシステムコールスタブ実装
int _write(int file, char *ptr, int len) {
    // stdout（ファイルディスクリプタ1）のみを処理
    if (file == STDOUT_FILENO) {
        int i;
        for (i = 0; i < len; i++) {
            // UART経由で文字を送信（必要なら待機）
            my_uart_putchar(ptr[i]);
        }
        return len; // 書き込んだ文字数を返す
    }
    // 他のファイルディスクリプタを処理するか、エラーを返す（例：EBADF）
    // errno = EBADF;
    return -1;
}
```
*（注意：正確なシグネチャや必要なインクルードファイルは、ツールチェーンやターゲットによって若干異なる場合があります。）*

-   **長所:** 成熟しており、広く採用されている（特に`arm-none-eabi-gcc`のようなツールチェーンを通じてARM Cortex-Mでよく使われる）、多くの組込みタスクに適した機能セットを持つ。
-   **短所:** デフォルトでは比較的大容量になる可能性があり、プラットフォーム固有のシステムコール実装が必須となる。
-   **典型的な用途:** ベアメタルファームウェア、RTOSベースのアプリケーション（FreeRTOS、Zephyrなどがしばしば使用）、クロスコンパイルツールチェーン。

### picolibc

-   **起源:** NewlibとAVR Libcの両方からのアイデアを組み合わせ、Keith Packardによって開発されました。
-   **目標:** 32/64ビット組込みシステム向けに**サイズ**を最適化し、フットプリントと使いやすさ、最新ツールのバランスを取ったCライブラリを提供すること。
-   **主な特徴:** Newlib/AVR Libcのコードをベースとし、最小化に重点を置いています。設定とビルドを容易にする**Mesonビルドシステム**を使用し、複数のstdio実装（整数のみの最小限の`printf`、浮動小数点サポートなど）をビルド時に選択可能です。最適化された数学ルーチンを含みます。Newlibと同様に、ユーザーによる実装が必要な**システムコールスタブ**機構に依存します。
-   **例（Syscallスタブ）:** picolibcにおける`_write`や`_sbrk`のようなシステムコールの実装方法は、Newlibと同一です。上記のNewlibの例で示したような、プラットフォーム固有のコードを提供する必要があります。違いは、`printf`のような関数のpicolibc内部実装が、より小さくなるように設計されている点にあります。
-   **長所:** デフォルトのNewlibよりも著しく小さく、モダンで柔軟なビルドシステムを持ち、サイズ最適化のための優れたオプションがあり、活発に開発されている。
-   **短所:** Newlibよりも比較的新しいですが、急速に普及が進んでいます。
-   **典型的な用途:** コードサイズが重要でありながら標準Cライブラリ機能が必要な組込みプロジェクト（特にARM Cortex-M、RISC-V）。スペースが限られている場合にNewlibの強力な代替となります。

### nanolib (Newlib-nano / nano.specs)

-   **起源:** 独立したライブラリではなく、Newlibの**設定バリアント**であり、通常は`arm-none-eabi-gcc`のようなツールチェーンに含まれています。
-   **目標:** 特にI/Oやメモリ割り当ての機能を削ぎ落とすことで、極めてサイズが最適化されたNewlibのビルドを提供すること。
-   **主な特徴:** リンク段階でコンパイラフラグ（`-specs=nano.specs`）を使って有効化します。標準のNewlib関数（特に`printf`、`scanf`、`malloc`）を最小限のバージョンに置き換えます（例：nanolibの`printf`は、デフォルトではコードサイズ削減のために浮動小数点サポートを欠いています）。コードサイズのために機能を犠牲にします。
-   **例（有効化とその影響）:**
    1.  **コンパイルとリンクコマンド:**
        ```bash
        arm-none-eabi-gcc my_app.c -mcpu=cortex-m0plus -mthumb -Os \
                         -Wl,--gc-sections,--print-memory-usage \
                         -specs=nano.specs -o my_app.elf
        ```
        `-specs=nano.specs`フラグは、リンカにnanoバリアントのライブラリを使用するよう指示します。
    2.  **コードへの影響（概念）:**
        ```c
        #include <stdio.h>

        int main() {
            float pi = 3.14159f;
            // nano.specsを使用すると（デフォルトでは）、%f は
            // 他のフラグで浮動小数点サポートを明示的にリンクしない限り、
            // おそらくゴミまたは0を出力します。
            printf("Integer: %d, Float: %f\n", 123, pi);
            // 整数のフォーマットは通常問題なく動作します。
            printf("Integer only: %d\n", 456);
            return 0;
        }
        ```
-   **長所:** コンパイラフラグ一つでlibcのフットプリントを大幅に削減できます。非常に制約の厳しいマイクロコントローラに最適です。
-   **短所:** 機能が削減されます（デフォルトで浮動小数点`printf`/`scanf`がない、`malloc`が簡略化されている可能性がある）。挙動が完全なNewlibと微妙に異なる場合があります。ツールチェーン固有のビルドに依存します。
-   **典型的な用途:** Flash/ROMスペースが極端に限られている超小型マイクロコントローラプロジェクト（例：Cortex-M0/M0+）。

### dietlibc

-   **起源:** Felix von Leitnerによって開発されました。
-   **目標:** Linuxシステム上で**静的リンクされた実行可能ファイル**をターゲットとする、可能な限り最小のC標準ライブラリであること。
-   **主な特徴:** サイズを最優先して徹底的に最適化されています。Linuxシステムコールを直接実装します（*Linux上では*スタブ層は不要）。互換性を目指しつつも、あまり一般的でないPOSIX機能は省略したり、glibcやNewlibとは異なるエッジケースの扱いをしたりする場合があります。主に静的リンク用に設計されています。
-   **例（静的リンク）:** Dietlibcには、静的リンクを簡素化するためのGCCラッパースクリプト（`diet gcc`など）が付属していることがよくあります：
    ```bash
    # dietlibcラッパースクリプトを使用
    diet gcc -static my_linux_app.c -o my_linux_app_static

    # 手動で同様の結果を得る（概念、パスは異なる）
    # gcc my_linux_app.c -nostdlib /path/to/dietlibc/lib/crt0.o \
    #     -I/path/to/dietlibc/include -L/path/to/dietlibc/lib -ldiet -lc
    ```
    結果として得られるのは、通常、非常に小さく自己完結した実行可能ファイルであり、組込みLinuxデバイスに最適です。
-   **長所:** 極めて小さなバイナリサイズ、シンプルなアプリでは起動が高速になる可能性。
-   **短所:** 主にLinuxに焦点を当てており、非Linuxやベアメタルへの移植性は低い。他よりもPOSIX準拠度が低い。最近は開発があまり活発ではないように見える。非標準的な挙動をすることがある。
-   **典型的な用途:** 実行可能ファイルのサイズ最小化が最優先される組込みLinuxシステム（ルーター、アプライアンスなど）。

## 主な違いの比較

| 特徴             | Newlib                     | picolibc                     | nanolib (Newlib-nano)         | dietlibc                    |
| :--------------- | :------------------------- | :--------------------------- | :---------------------------- | :-------------------------- |
| **主な目標**     | 移植性、組込み             | サイズとバランス（組込み）   | 極限のサイズ（Newlib経由）    | 最小サイズ（Linux静的）   |
| **サイズ**       | 中〜大（設定可）           | 小〜中                       | 非常に小さい                  | 極めて小さい                |
| **プラットフォーム** | ベアメタル, RTOS, Linux    | ベアメタル, RTOS, Linux      | ベアメタル, RTOS（Newlib経由）| 主にLinux                   |
| **システムコール**| スタブ（実装必要）         | スタブ（実装必要）           | スタブ（Newlib経由）          | 直接Linux Syscall           |
| **準拠性**       | 良好なC/POSIXサブセット    | 良好なC/POSIXサブセット      | 機能削減により低下            | ミニマリスト、Linux中心    |
| **ビルドシステム**| Autotools/Make             | Meson                        | ツールチェーンの一部(GCC specs)| Make                        |
| **主な利点**     | 成熟度、移植性             | サイズ/機能バランス、モダン  | ツールチェーンフラグで超小型  | 最小の静的Linuxバイナリ   |

## Cランタイム（crt0）との連携

[以前のCランタイムに関する投稿]({{< ref "/blog/c-runtime" >}})で詳述したように、`crt0`オブジェクトファイルは`_start`エントリーポイントを含み、`main`の前に重要なセットアップを実行します。これらの特殊なCライブラリを使用する場合、`crt0`はしばしば簡略化され、調整されます：

-   **Newlib/picolibc:** 通常、組込みツールチェーン（例：`arm-none-eabi-gcc`）によって提供される最小限の`crt0`、またはRTOSやBSP（ボードサポートパッケージ）によって提供されるカスタム`crt0`を使用します。この`crt0`はメモリ（`.data`, `.bss`）を初期化し、スタックを設定し、（`malloc`が使用される場合は）`_sbrk`に必要なヒープポインタを設定する可能性があり、最後に`main`を呼び出します。
-   **nanolib:** ツールチェーン内で、派生元である完全版Newlibと同じ最小限の`crt0`を使用します。
-   **dietlibc:** しばしば、dietlibcの内部動作に合わせて特別に設計され、静的リンクされたLinux実行可能ファイルの起動オーバーヘッドを最小化するために高度に最適化された独自の`crt0`（`crt0.o`）をバンドルしています。

コンパイラフラグ（`-nostartfiles`（独自の`crt0`を提供）や`-nostdlib`（標準ライブラリ*と*スタートアップファイルを完全に除外））を使用することで、より細かい制御が可能になり、これらのライブラリを統合する際、特にベアメタルシナリオでしばしば必要となります。

## プロジェクトに適したライブラリの選択

最適なlibcの選択は、プロジェクト固有の制約に大きく依存します：

-   **ベアメタル/RTOS上で幅広い互換性、機能、成熟度が必要な場合:** **Newlib**は実績のある選択肢です。ただし、そのサイズを受け入れ、必要なシステムコールを実装できることが前提です。
-   **ベアメタル/RTOS上でコードサイズを優先しつつ、妥当なC標準サポートが必要な場合:** **picolibc**は、Newlibに対するモダンでより小さな代替手段を提供し、しばしば大幅なサイズ削減を実現します。
-   **`arm-none-eabi-gcc`（または類似のツールチェーン）を使用していて、深刻なFlash/ROM制限に直面している場合:** 手軽なサイズ削減策として**nanolib**（`-specs=nano.specs`）を試してみてください。ただし、削減された機能（例：浮動小数点表示）が許容範囲内であることを確認してください。
-   **組込みLinux向けに小型の静的リンク実行可能ファイルを開発している場合:** **dietlibc**はこの特定のニッチ分野で優れており、非常に小さなバイナリを生成します。

選択を検証するためには、常に実際のターゲットハードウェア上で最終的なバイナリサイズ、RAM使用量、およびパフォーマンスを測定してください。

## まとめ

C標準ライブラリは不可欠なものですが、特に多様な組込みシステムの世界においては、万能な解決策というわけにはいきません。**Newlib**、その軽量版である**nanolib**、モダンでサイズ最適化された**picolibc**、そしてミニマリストな**dietlibc**のようなライブラリは、glibcのような大規模なライブラリに対する重要な代替手段を提供します。これらは、コードフットプリント、機能セット、移植性、および標準準拠性の間で、それぞれ異なるトレードオフを提供します。これらの選択肢と、以前に議論した基礎となるCランタイムメカニズムを理解することで、開発者は最もリソースに制約のあるプラットフォーム上でさえも、効率的で機能的なソフトウェアを構築することができます。適切なlibcを選択することは、組込みアプリケーションを最適化する上で重要なステップであり、厳しいメモリ予算内に収めつつ必要な標準機能を提供することを保証します。

## 参考文献

-   [Cランタイムを理解する：crt0, crt1, crti, crtn]({{< ref "/blog/c-runtime" >}})
-   [Newlib プロジェクトページ][1]
-   [picolibc リポジトリ][2]
-   [dietlibc ホームページ][3]
-   [C標準ライブラリの比較（Wikipedia）][4] - *より広範な概要を提供*

[1]: https://sourceware.org/newlib/
[2]: https://github.com/picolibc/picolibc
[3]: https://www.fefe.de/dietlibc/
[4]: https://en.wikipedia.org/wiki/Comparison_of_C_standard_libraries

{{<post-socials language="jp" page_content_type="blog" telegram_post_id="31" x_post_id="1910145157221269796">}}
{{<ai-translated>}}
